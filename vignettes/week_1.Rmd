---
title: "Week 1"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Week 1:  Setting Up}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(datascience.curriculum)
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction

This course will focus on what I believe are the essential skills necessary for a laboratory-based scienties to use R and Rstudio in an effective way.  There are many other detailed resources out there for you.  [Software carpentry](https://software-carpentry.org/lessons/previous/) has very good tutorials for R, python, git and working with the command line.  These are good if you want to extend your knowledge beyond what we cover here.  I will try to show you what I view as best data practices for rigorous and reproducible biological research.  

Learning R at times will seem like learning a foreign language.  You will make errors.  **Always remember that you will never be the first person to encounter an error.  Learn how to google the error message and 99% of the time you will find your answer in the first 3 hits**.  This is how you learn. 

## R and Rstudio

R is a statistical programming language.  It is like the engine for an automobile.  RStudio is like the rest of the automobile.  Rstudio is known as an integrated development environment or IDE.  

Rstudio provides two main ways of interacting with R:  directly via the R Console and via R scripts.

* R console:  you type in commands and output is usually returned to the console.  The commands are logged in a history file if you really need them, but this is inconvenient.  A better option is to use scripts.  
  
  **Warning and Error messages will appear in the console.  Always pay attention to what they are saying.** 

* R scripts:  these are text files.  When you run 1 or more lines, Rstudio feeds them into the console and R follows the commands.  This is good because you always have a plain text record of what you did.  So when you build up a multi-step analysis it is easy to see how you got the end product.  Better than running the whole file is "sourcing" the file.  You can do this by typing Ctrl+Shift+S or clicking the "Source" button in the upper right corner of the source pane (usually top-left) in Rstudio.  Why is this better?  Let's say you left an error in your script.  Maybe the presence of this error changes the final output you are trying to produce.  If you run all of the lines, R will notify you of the error and then keep going.  Easy to miss if this is the only error.  If you source the file, it will stop completely on errors so you don't end up with errors you aren't aware of.

  **You always want your programs to error in obvious ways so you don't carry on with incorrect data.**

Rstudio provides a number of standard panes that display useful information.  We will review these in class or you can explore them on your own.

## Packages

Packages are chunks of code and/or data that people have written and made available to us to use. The main reason we use R is that there is a large library of useful packages for the biological sciences that we can build our work on, all of which are free to use. 

Packages are most often stored and distributed as compressed binary files via standard repositories.  The two most common are [CRAN](https://cran.r-project.org/) and [Bioconductor](https://www.bioconductor.org/).  Packages can also be distributed as source code (text based files), usually via github. 

**What happens when we "install" packages?**

R downloads the compressed file and then unpacks it in a library directory on your computer or server.  You can find the original source files if you know where your R package library is stored (more on this when we discuss Renv).  If you want to know how a function is working, this is one way to find it.

The function you use to install packages is ```install.packages("<package name>")```.  This is most useful for official CRAN packages. For a more versatile tool, install renv with ```install.packages("renv")``` and then run ```renv::install("<package name>")```.  Using install from Renv will handle CRAN, bioconductor (prefix package name with bioc::), github, and local sources pretty easily, so this is the recommended approach.

**If you ever get an error that says a function or package is unavailable, the first thing you want to do is make sure the package is installed.**  You may not recognize what it is but it may be required by another package you wish to use.  This is called a dependency.

Once you have installed a package its functions are available to be called using the package name followed by 2 colons such as ```blaseRtools::bb_var_umap(cds)```. But this is not always the best way to go.  

To make all of the functions from a package available, you need to run ```library("<package name>")```.  This will attach all of the functions from that package to your session.   

Beware of attaching more packages than you actually need though because there could be "namespace conflicts".  This happens when the same term applies to two different functions from two different packages.  R picks one and goes with it without clearly indicating that it is doing so.  This is a common source of errors.

## Projects

A project is a self-contained group of files for your R data analysis.  This should align conceptually with your experiments.  If you have a set of single cell data and imaging data related to the same scientific concept or paper then it can all go in the same project.

Projects automatically define their working directory to be the root of the projects.  That means you can reference any file in the root directory by typing its name like so: "file.R".  If that file was one directory down, it would be "directory/file.R". There is almost no reason ever to change this behavior.

Packages are self-contained.  You can put them where you want and move them without breaking anything inside.

You always want to be working in a project.

### Setting up a project

The best way to do this is through automated commands, rather than through the program menus.  I have these lines saved in a script I always use to initialize a project.  This way all of my projects are structured the same way.

```{r eval=FALSE}
# create a project called rclass_example in your home directory
usethis::create_project("~/rclass_example")

# generate a standard license file for your work 
usethis::use_mit_license("Brad Blaser")

# generate a readme file so you can document your work
usethis::use_readme_md()

# use git and set up a private remote repository on github
# these will fail unless you have git installed on your computer and 
# have a github account. See below
usethis::use_git()
usethis::use_github(private = TRUE)
```

You can open or close projects by selecting from the dropdown menu in the top right of Rstudio 

Be aware: any time you close or switch projects, the R session is restarted and you will lose all objects in your Global Environment.

## Global Environment

Environment is a very overloaded word in R, by which I mean it is used to name too many separate concepts, and so is difficult to learn.  It is also referred to as "workspace" which is a much better term.

The global environment is like short-term memory.  It holds values and the names we give to these values in order to reference them.  You may think of the names as "variables".  Values can be data or code (functions).  Fundamentally, the global environment is a set of name-value relationships.

R maintains many different environments concurrently.  Each package you attach with the ```library``` command gets its own environment.  The term "global" is even more confusing because it is not really global in the sense that it encompasses all other environments.  Rather, it is the highest priority environment.  If you enter a variable name into R, it always looks in the global environment first and then goes down the line until it hits the package:base environment.  So if I write a function in my R script called "mean" that for some reason calculates the median of a set of numbers (not a great idea), R will store that in the global environment.  Later on if I ask R to use the "mean" function, it will use the version from the global environment and not the version from the base environment.  It will calculate the median instead of the mean in this case.

```{r}
# produce a list of all environments
search()
```

Since the global environment gets wiped out every time you change projects or restart R, you have to have a way to save what you want in permanent storage and to recreate the rest as needed from code.  We will discuss this more when we talk about building packages. 

## Renv environment

The final sense of environment you need to know relates to package versions.

On occasion you will write an R script that depends on a specific version of a package, but breaks if you were to update that package to a newer version.

The way around this is to use Renv to control package versions.  This can cause some headaches but is generally worth the trouble.

What happens is Renv discovers all of the packages you use in your code, copies or newly installs those pieces of software into a directory within the project, and then maintains a list, called a lockfile, of all the versions of all the packages being used.

This action changes the package library for your project to the renv directory within the project itslef.  

```{r eval=FALSE}
# initiate an Renv environment in a new project
renv::init()

# install packages listed in the lockfile
renv::restore()

# install any packages that get missed
renv::install()
```

## Project organization

I keep all of my R scripts in a directory called "R".  The root directory of the project I reserve for files related to the "software development" aspect of the project.  This is relatively flexible for simple data analysis projects; the rules become more strict when we build packages.   

## Extra credit:  Basic git operation for the single user

You want to try to use git and github.  There is a vast array of resources for you to read about git and troubleshoot issues.  Briefly, it is a program that tracks changes to text files.  Since all of the code you will write is text-based this is a great resource for you to keep track of your progress on your work.

Git tracks changes to files in a group of files known as a repository.  The way we are using it here, your project is the repository.  Github is simply a website that hosts a copy of your repository on the web.  This is how you will share your work with journal reviewers and editors and others.

### Setting up github from R

```{r eval = FALSE}
# make sure you have an account and are signed in

# create a personal access token at the github website
usethis::create_github_token()

# run this and enter your token at the prompt
gitcreds::gitcreds_set()

# if you encounter errors you may have an old token stored elsewhere on your system.
# to fix this, run this command, delete the PAT line, save, restart R and try again.
usethis::edit_r_environ()

```

The necessary permissions should be set automatically by these commands.  By default, the token expires after 30 days, but you can override this.  

Assuming the commands above have run properly you should be ready to use git and github.  Rstudio provides a graphical interface for working with git which I find difficult to use.  Working in the terminal is easier and gives you access to all options for branching, merging and checking out old versions of your code.

The basic rules are these:

* when you have reached a convenient "save point" for your work, in the terminal run ```git add .```  Git scans everything you did and indexes the changes to all of your files.
* run ```git status``` to check and be sure you haven't accidentally added large binary files (like images, r data files etc).  You should only have text-based files like .csv, .R, or .Rmd
* run ```git commit -m "<insert a brief message here>"``` to save or "commit" your work.  For the message, try to explain what the changes represent in just a few words.
* run ```git push``` to send the changes up to github.

I have a standard [.gitignore](https://github.com/blaserlab/development/blob/main/.gitignore) file which you can use to prevent accidentally committing .rda files.  Just save it in the top level directory of your git-enabled project. 

If you run into problems, the error messages are usually informative.  If you have trouble understanding an error or it isn't helpful, just google it.

Git is designed to facilitate collaboration and there are many strategies for handling this.  This subject is outside the scope of this course, but if you would like additional information for my recommended practices please let me know.

One common use-case for git for the single user is to "un-delete" files.  You can do this as long as the files were previously committed.  To go back in time and recover the previously committed version, run ```git log``` to review your commit history.  Add and commit any outstanding changes to your repository as outlined above.  Then run ```git checkout <commit id>``` to rewind the state of your repository to the desired commit.  Copy the file(s) you want to resurrect to a location external to the repository. Run ```git switch -``` to go back to your latest commit.  Make your changes and go from there.

If you are using git, it is important to be comfortable with using these commands in the terminal.  However, there is a nice package called "gert" which lets you control git from the R console or using scripted commands.  

```{r eval = FALSE}
# make sure all work is saved
# add and commit all outstanding changes in one step
gert::git_commit_all("commit message here")

# push your changes to github 
gert::git_push()

```

This is a pretty slick way to save your progress without leaving R.


## Exercises

1.  Use the code blocks from this vignette to make a new R project on your system.  Modify as necessary.  If you have trouble with the git commands omit them for now.

2.  Make an R script called "dependencies.R".  Put it in a directory in your new project called "R".

3.  Install renv if you haven't already.

4.  Initiate renv in your new project.

5.  Use ```renv::install()``` to install "tidyverse".

6.  Try attaching the tidyverse package to your session using ```library()```.  If there are missing package dependencies install those as well.

7.  Extra credit:  save your commands from 4, 5 and 6 to dependencies.R, then add, commit, and push to your github site.
