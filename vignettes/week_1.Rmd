---
title: "Week 1"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Week 1:  Setting Up}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(datascience.curriculum)
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

## Introduction

This course will focus on what I believe are the essential skills necessary for a laboratory-based scienties to use R and Rstudio in an effective way.  There are many other detailed resources out there for you.  

* [Software carpentry](https://software-carpentry.org/lessons/previous/) has very good tutorials for R, python, git and working with the command line.  
* [R for data science](https://r4ds.had.co.nz/) is a book written by Hadley Wickham who wrote much of the software we use in R
* [Modern dive](https://moderndive.com/) is focused on modeling if you are interested in more clinical data sets 

These and many others are good resources if you want to extend your knowledge beyond what we cover here.    

Learning R at times will seem like learning a foreign language.  You will make errors.  **Always remember that you will never be the first person to encounter an error.  Learn how to google the error message and 99% of the time you will find your answer in the first 3 hits**.  This is how you learn. 

## R and Rstudio

R is a statistical programming language.  It is like the engine for an automobile.  RStudio is like the rest of the automobile.  Rstudio is known as an integrated development environment or IDE.  

Rstudio provides two main ways of interacting with R:  directly via the R Console and via R scripts.

* R console:  you type in commands and output is usually returned to the console.  The commands are logged in a history file if you really need them, but this is inconvenient.  A better option is to use scripts.  
  
  **Warning and Error messages will appear in the console.  Always pay attention to what they are saying.** 

* R scripts:  these are text files.  When you run 1 or more lines, Rstudio feeds them into the console and R follows the commands.  This is good because you always have a plain text record of what you did.  So when you build up a multi-step analysis it is easy to see how you got the end product.  Better than running the whole file is "sourcing" the file.  You can do this by typing Ctrl+Shift+S or clicking the "Source" button in the upper right corner of the source pane (usually top-left) in Rstudio.  Why is this better?  Let's say you left an error in your script.  Maybe the presence of this error changes the final output you are trying to produce.  If you run all of the lines, R will notify you of the error and then keep going.  Easy to miss if this is the only error.  If you source the file, it will stop completely on errors so you don't end up with errors you aren't aware of.

  **You always want your programs to error in obvious ways so you don't carry on with incorrect data.**

Rstudio provides a number of standard panes that display useful information.  We will review these in class or you can explore them on your own.

## Packages

Packages are chunks of code and/or data that people have written and made available to us to use. The main reason we use R is that there is a large library of useful packages for the biological sciences that we can build our work on, all of which are free to use. 

Packages are most often stored and distributed as compressed binary files via standard repositories.  The two most common are [CRAN](https://cran.r-project.org/) and [Bioconductor](https://www.bioconductor.org/).  Packages can also be distributed as source code (text based files), usually via github. 

**What happens when we "install" packages?**

R downloads the compressed file and then unpacks it in a library directory on your computer or server.  Then the functions and data are available for you to use in your R project.

```{r eval=FALSE}
# the base function you use to install packages is...
install.packages("<package name>")

# install the usethis and renv packages which we will be using in this lecture
install.packages("usethis")
install.packages("renv")

# use renv for a more versatile installer 
renv::install("<package name>")

```


The base install function is most useful for official CRAN packages.  Using install from Renv will handle CRAN, bioconductor (prefix package name with bioc::), github, and local sources pretty easily, so this is the recommended approach.

**If you ever get an error that says a function or package is unavailable, the first thing you want to do is make sure the package is installed.**  You may not recognize what it is but it may be required by another package you wish to use.  This is called a dependency.

Once you have installed a package its functions are available to be called using the package name followed by 2 colons such as ```blaseRtools::bb_var_umap(cds)```. But this is not always the best way to go.  

To make all of the functions from a package available, you need to run ```library("<package name>")```.  This will attach all of the functions from that package to your session.   

Beware of attaching more packages than you actually need though because there could be "namespace conflicts".  This happens when the same term applies to two different functions from two different packages.  R picks one and goes with it without clearly indicating that it is doing so.  This is a common source of errors.

## Projects

A project is a self-contained group of files for your R data analysis.  This should align conceptually with your experiments.  If you have a set of single cell data and imaging data related to the same scientific concept or paper then it can all go in the same project.

Projects automatically define their working directory to be the root of the projects.  That means you can reference any file in the root directory by typing its name like so: "file.R".  If that file was one directory down, it would be "directory/file.R". There is almost no reason ever to change this behavior.

Packages are self-contained.  You can put them where you want and move them without breaking anything inside.

You always want to be working in a project.

### Setting up a project

The best way to do this is through automated commands, rather than through the program menus.  I have these lines saved in a script I always use to initialize a project.  This way all of my projects are structured the same way.

```{r eval=FALSE}
# create a project called rclass_example in your home directory
usethis::create_project("~/rclass_example")

# generate a standard license file for your work 
usethis::use_mit_license("Brad Blaser")

# generate a readme file so you can document your work
usethis::use_readme_md()

# use git and set up a private remote repository on github
# these will fail unless you have git installed on your computer and 
# have a github account. See below
usethis::use_git()
usethis::use_github(private = TRUE)
```

You can open or close projects by selecting from the dropdown menu in the top right of Rstudio 

Be aware: any time you close or switch projects, the R session is restarted and you will lose all objects in your Global Environment.

## Global Environment

Environment is a very overloaded word in R, by which I mean it is used to name too many separate concepts, and so is difficult to learn.  It is also referred to as "workspace" which is a much better term.

The global environment is like short-term memory.  It holds values and the names we give to these values in order to reference them.  You may think of the names as "variables".  Values can be data or code (functions).  Fundamentally, the global environment is a set of name-value relationships.

R maintains many different environments concurrently.  Each package you attach with the ```library``` command gets its own environment.  The term "global" is even more confusing because it is not really global in the sense that it encompasses all other environments.  Rather, it is the highest priority environment.  If you enter a variable name into R, it always looks in the global environment first and then goes down the line until it hits the package:base environment.  So if I write a function in my R script called "mean" that for some reason calculates the median of a set of numbers (not a great idea), R will store that in the global environment.  Later on if I ask R to use the "mean" function, it will use the version from the global environment and not the version from the base environment.  It will calculate the median instead of the mean in this case.

```{r}
# produce a list of all environments
search()
```

Since the global environment gets wiped out every time you change projects or restart R, you have to have a way to save what you want in permanent storage and to recreate the rest as needed from code.  We will discuss this more when we talk about building packages. 

## Renv environment

The Renv environment refers to a version-controlled set of R packages that are specifically installed in an R project.  It is analogous to a conda environment in Python.

Why do you want to deal with this?

On occasion you will write an R script that depends on a specific version of a package, but breaks if you were to update that package to a newer version.

Or perhaps you want to share the project with a collaborator who has a different set of packages installed on their system which may produce errors or different results than the packages you are working with.

The way around this is to use Renv to control package versions.  This can cause some headaches but is generally worth the trouble.

What happens is Renv discovers all of the packages you use in your code and copies or newly installs those pieces of software into a cache directory on your system.  This is usually difficult to find but this is not a problem because Renv knows how to find it.  Then Renv puts links to the cache into your project, rather than the software itself.  This keeps the disk-space footprint of the project very small.  Finally it maintains a list, called a lockfile, of all the versions of all the packages being used by the project.  Each project will have its own library of Renv links and its own lockfile.

When you update a package in your project, Renv links to the new version if available in the cache, or installs it in the cache first if necessary.  If you find something has broken after the update, the old version of the package is still available so you can go back to it if necessary.  This gives you a great deal of control over the software used in your analysis.

```{r eval=FALSE}
# initiate an Renv environment in a new project
renv::init()

# install packages listed in the lockfile
renv::restore()

# update or install new packages
renv::install()
```

## Project organization

I keep all of my R scripts in a directory called "R".  Within this I make scripts for setting up the project (```dev.R```), managing packages and attaching libraries (```dependencies.R```), and setting up aesthetic and input/output configurations (```configs.R```).  The main analysis scripts for the project will go in the R folder and may go in subdirectories if there are a lot of them.  This arrangement is very flexible for simple data analysis projects; the rules become more strict when we build packages.

I avoid putting any new files in the root directory of the project after it is set up and reserve this for the configuration files generated by the usethis package. 

## Extra credit:  Basic git operation for the single user

You want to try to use git and github.  There is a vast array of resources for you to read about git and troubleshoot issues.  Briefly, it is a program that tracks changes to text files.  Since all of the code you will write is text-based this is a great resource for you to keep track of your progress on your work.

Git tracks changes to files in a group of files known as a repository.  The way we are using it here, your project is the repository.  Github is simply a website that hosts a copy of your repository on the web.  This is how you will share your work with journal reviewers and editors and others.

### Setting up git and github from R

```{r eval = FALSE}
# make sure you have a github account
# https://github.com/join

# install git
## Windows ->  https://git-scm.com/download/win
## Mac     ->  https://git-scm.com/download/mac
## Linux   ->  https://git-scm.com/download/linux

# configure git in Rstudio
usethis::use_git_config(user.name = "YourName", user.email = "your@mail.com")

# create a personal access token at the github website
# set the expiration date as desired
# permissions should be set automatically
usethis::create_github_token()

# run this and enter your token at the prompt
gitcreds::gitcreds_set()

# if you have trouble accessing github, you may need to edit the .Renviron file
# this is the third usage of the term environment (sorry)
# to edit this file, run 
usethis::edit_r_environ()
# store your personal access token on  new line with: GITHUB_PAT=xxxyyyzzz
# press enter to generate a new line and then save
# restart R
# only do this if you are having trouble connecting to github from R
```

The necessary permissions should be set automatically by these commands.  By default, the token expires after 30 days, but you can override this.  

Assuming the commands above have run properly you should be ready to use git and github.  Rstudio provides a graphical interface for working with git which I find inconventient to use.  Working in the terminal is easier and gives you access to all options for branching, merging and checking out old versions of your code.

The basic rules are these:

* when you have reached a convenient "save point" for your work, in the terminal run ```git add .```  Git scans everything you did and indexes the changes to all of your files.
* run ```git status``` to check and be sure you haven't accidentally added large binary files (like images, r data files etc).  You should only have text-based files like .csv, .R, or .Rmd
* run ```git commit -m "<insert a brief message here>"``` to save or "commit" your work.  For the message, try to explain what the changes represent in just a few words.
* run ```git push``` to send the changes up to github.

I have a standard [.gitignore](https://github.com/blaserlab/development/blob/main/.gitignore) file which you can use to prevent accidentally committing .rda files.  Just save it in the top level directory of your git-enabled project. 

If you run into problems, the error messages are usually informative.  If you have trouble understanding an error or it isn't helpful, just google it.

Git is designed to facilitate collaboration and there are many strategies for handling this.  This subject is outside the scope of this course, but if you would like additional information for my recommended practices please let me know.

One common use-case for git for the single user is to "un-delete" files.  You can do this as long as the files were previously committed.  To go back in time and recover the previously committed version, run ```git log``` to review your commit history.  Add and commit any outstanding changes to your repository as outlined above.  Then run ```git checkout <commit id>``` to rewind the state of your repository to the desired commit.  Copy the file(s) you want to resurrect to a location external to the repository. Run ```git switch -``` to go back to your latest commit.  Make your changes and go from there.

If you are using git, it is important to be comfortable with using these commands in the terminal.  However, there is a nice package called "gert" which lets you control git from the R console or using scripted commands.  

```{r eval = FALSE}
# make sure all work is saved
# add and commit all outstanding changes in one step
gert::git_commit_all("commit message here")

# push your changes to github 
gert::git_push()

```

This is a pretty slick way to save your progress without leaving R.


## Exercises

1.  Use the code blocks from this vignette to make a new R project on your system.  Modify as necessary.  If you have trouble with the git commands omit them for now.

2.  Save new R scripts:  "R/dev.R", "R/dependencies.R", "R/configs.R".  Add commands for setting up the project and interacting with git to dev.R.  Add commands for installing and loading packages to dependencies.R.  Leave configs.R blank for now. 

3.  Install renv if you haven't already.

4.  Initiate renv in your new project.

5.  Use ```renv::install()``` to install "tidyverse".

6.  Try attaching the tidyverse package to your session using ```library()```.  If there are missing package dependencies install those as well.

7.  Extra credit:  save your commands on the appropriate scripts, then add, commit, and push to your github site.
